name=Clone Entwurf
description=Das "java.lang.Cloneable" Interface zu implementieren ist ein haeufiger Weg um eine Kopier-Funktion fuer eine bestimmte Klasse von Objekten bereitzustellen. Obwohl das nicht der ideale Weg ist um dies zu implementieren, wie etwa Joshua Bloch in seinem Buch "Effective Java" erklaert, ist es trotzdem eine valide Option, wenn es korrekt gemacht wird. Wie die CWE-580 (CWE: "Common Weakness Enumeration", zu deutsch: "Gemeinsame Schwachstellen Sammlung") zeigt, sollte konsistent bei jedem Ueberschreiben der "clone"-Methode ein Aufruf von "super.clone()" erfolgen, um den richtigen Laufzeittyp des geklonten Objekts zu erhalten. Dies ist entscheidend, wenn eine Vererbungshierarchie implementiert wird. Dies stellt auch die Einhaltung der verpflichtenden Teile des Vertrags von "clone" in "java.lang.Object" sicher, und zwar, dass ein neues Objekt mit dem Laufzeittyp des Objekts, auf welchem "clone" aufgerufen wurde, zurueckgegeben wird. SonarSource definiert ebenfalls die Regel "Classes that override 'clone' should be 'Cloneable' and call 'super.clone()'", welche ein Fehlen des "super.clone()" Aufrufs als Code Smell markiert.
source#1=J. Bloch: Effective Java, Kap. 3.4
source#2=https://cwe.mitre.org/data/definitions/580
source#3=https://rules.sonarsource.com/java/RSPEC-1182/
additionalInformation=Eine Ausnahme fuer die Regel, das jede Ueberschreibung "super.clone()" aufrufen muss, koennte fuer "finale" Klassen gemacht werden, da von diesen nicht geerbt werden kann. Wie jedoch in der Beschreibung erwaehnt, sollte "Cloneable" zu implementieren nicht der bevorzugte Weg sein, um eine Kopier-Funktionalitaet zu implementieren. Dieses Problem kann in vielen Faellen zum Beispiel auch mit einem Kopier-Konstruktor (siehe das "Kopier-Konstruktor" Perfume) oder mit einer selbst definierten Kopier-Methode (z.B. ueber ein Interface) geloest werden.