package de.jsilbereisen.perfumator.engine.detector.perfume;

import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.ConstructorDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.TypeDeclaration;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.symbolsolver.javaparsermodel.JavaParserFacade;
import lombok.Builder;
import org.apache.commons.lang3.concurrent.BasicThreadFactory;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import de.jsilbereisen.perfumator.engine.detector.Detector;
import de.jsilbereisen.perfumator.model.DetectedInstance;
import de.jsilbereisen.perfumator.model.perfume.Perfume;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * <p>
 *     {@link Detector} for the "Builder pattern" {@link Perfume}. This detects <i>basic</i> implementation
 *     of the Builder design pattern.
 * </p>
 * <p>
 *     To decide whether a top-level class implements the builder pattern in a basic form, we apply the following
 *     criteria:
 *     <ul>
 *         <li>
 *             The class has at least one <b>public static</b> nested class (not an interface!) whose name ends
 *             with "Builder". See {@link #hasBuilderPattern}.
 *         </li>
 *         <li>
 *             The class has a non-public constructor that takes the builder as its parameter. See
 *             {@link #analyseConstructors}.
 *         </li>
 *         <li>
 *             The outer class and the builder have at least {@link #MIN_REQUIRED_FIELDS} fields. See
 *             {@link #hasBuilderPattern} and {@link #checkConstructorAndFieldRequirements}.
 *         </li>
 *         <li>
 *             The builder class has exactly one public/protected constructor (may be default constructor),
 *             or if the constructor is private, the top-level class has a static "builder()" method that has the
 *             builder as its return type (checked without type args), see e.g. {@link Builder} annotation from
 *             <i>Project Lombok</i>. See {@link #checkConstructorAndFieldRequirements} and {@link #hasBuilderMethod}.
 *         </li>
 *         <li>
 *             The builder class offers a public/protected "build" method with no parameters, with the outer class as
 *             the return type. See {@link #checkBuildersMethods}.
 *         </li>
 *         <li>
 *             All other non-static public methods of the builder have the builder itself as the return type (or
 *             {@code void}, for something like a "reset" method. Seen here: {@link BasicThreadFactory.Builder#reset()}.
 *             See {@link #checkBuildersMethods}.
 *         </li>
 *     </ul>
 * </p>
 * <p>
 *     There are obviously a lot of possible variations for applying the "Builder" Design pattern. These criteria are
 *     mainly derived from Joshua Bloch's book "Effective Java", and some simple extensions found examples in
 *     established libraries. Obviously a lot of Builders will be missed (for example if they are implemented
 *     as a top-level class; Top-level class uses an all-args constructor, like generated by {@link Builder}), feel free to
 *     extend the Perfume.
 * </p>
 */
public class BuilderPatternDetector implements Detector<Perfume> {

    /**
     * The minimal amount of fields that the builder has to have in order to be seen as perfumed.
     * Joshua Bloch mentions in his book "Effective Java" that the amount of
     * fields for a builder to be worth are in his opinion "a hand full". At some point he mentions the number "4",
     * so this is what we take.
     */
    public static final int MIN_REQUIRED_FIELDS = 4;

    /**
     * Suffix (could also be the entire name) that builder classes should have. Not sure if there exists a written
     * convention for it.
     */
    public static final String BUILDER_SUFFIX = "Builder";

    /**
     * Method name for a factory method in the top-level class that has the Builder as its return type. Inspired by
     * the {@link Builder} annotation from <i>Project lombok</i>.
     */
    public static final String BUILDER_FACTORY_METHOD_NAME = "builder";

    private Perfume perfume;

    private JavaParserFacade analysisContext;

    @Override
    public @NotNull List<DetectedInstance<Perfume>> detect(@NotNull CompilationUnit astRoot) {
        List<DetectedInstance<Perfume>> detections = new ArrayList<>();

        for (TypeDeclaration<?> type : astRoot.getTypes()) {
            if (!type.isClassOrInterfaceDeclaration() || type.asClassOrInterfaceDeclaration().isInterface()) {
                continue;
            }

            if (hasBuilderPattern(type.asClassOrInterfaceDeclaration())) {
                detections.add(DetectedInstance.from(type, perfume, type));
            }
        }

        return detections;
    }

    @Override
    public void setConcreteDetectable(@NotNull Perfume concreteDetectable) {
        perfume = concreteDetectable;
    }

    @Override
    public void setAnalysisContext(@Nullable JavaParserFacade analysisContext) {
        this.analysisContext = analysisContext;
    }

    /**
     * Analyses whether the given top-level class implements a (basic) builder pattern. To check this, we validate the
     * criteria mentioned in the classes' JavaDoc.
     *
     * @param topLevelClass The top-level class to analyse.
     * @return {@code true} if a builder pattern was detected, applying the above described criteria.
     * @see BuilderPatternDetector Class documentation
     */
    private boolean hasBuilderPattern(@NotNull ClassOrInterfaceDeclaration topLevelClass) {
        if (topLevelClass.getFields().size() < MIN_REQUIRED_FIELDS) {
            return false;
        }

        // Find all public nested (=static) classes that end with BUILDER_SUFFIX
        List<ClassOrInterfaceDeclaration> potentialBuilders = topLevelClass.findAll(ClassOrInterfaceDeclaration.class,
                clazz -> !clazz.isInterface() && clazz.isNestedType() && clazz.isPublic() && clazz.isStatic()
                        && clazz.getNameAsString().endsWith(BUILDER_SUFFIX));
        if (potentialBuilders.isEmpty()) {
            return false;
        }

        // Check the constructors of the top-level class. Get the nested classes, where the top-level class has a
        // constructor for it.
        potentialBuilders = analyseConstructors(topLevelClass, potentialBuilders);
        if (potentialBuilders.isEmpty()) {
            return false;
        }

        // Remove all builders that have no/not only public/protected constructor(s) and less than MIN_REQUIRED_FIELDS.
        // Or if the constructor is private, then check for a "builder()" method in the top-level class
        potentialBuilders.removeIf(potentialBuilder -> !checkConstructorAndFieldRequirements(potentialBuilder, topLevelClass));
        if (potentialBuilders.isEmpty()) {
            return false;
        }

        return potentialBuilders.stream().anyMatch(potentialBuilder -> checkBuildersMethods(potentialBuilder,
                topLevelClass));
    }

    private List<ClassOrInterfaceDeclaration> analyseConstructors(@NotNull ClassOrInterfaceDeclaration topLevelClass,
                                                                  @NotNull List<ClassOrInterfaceDeclaration> potentialBuilders) {
        List<ClassOrInterfaceDeclaration> potentialBuildersWithConstructor = new ArrayList<>();

        topLevelClass.getConstructors().forEach(constructor -> {
            if (constructor.isPublic()) {
                return;
            }

            if (constructor.getParameters().size() != 1) {
                return;
            }

            Type paramType = constructor.getParameters().get(0).getType();
            if (!paramType.isClassOrInterfaceType()) {
                return;
            }

            String paramTypeName = paramType.asClassOrInterfaceType().getNameAsString();
            Optional<ClassOrInterfaceDeclaration> builderClass = potentialBuilders.stream()
                    .filter(clazz -> clazz.getNameAsString().equals(paramTypeName)).findFirst();

            builderClass.ifPresent(potentialBuildersWithConstructor::add);
        });

        return potentialBuildersWithConstructor;
    }

    private boolean checkConstructorAndFieldRequirements(@NotNull ClassOrInterfaceDeclaration potentialBuilder,
                                                         @NotNull ClassOrInterfaceDeclaration topLevelClass) {
        if (potentialBuilder.getFields().size() < MIN_REQUIRED_FIELDS) {
            return false;
        }

        List<ConstructorDeclaration> constructors = potentialBuilder.getConstructors();

        if (constructors.isEmpty()) {
            return true; // accept default constructor
        } else if (constructors.size() > 1) {
            return false; // allow at max 1 constructor; We use the Builder pattern to AVOID multiple overloads!
        }

        ConstructorDeclaration constructor = constructors.get(0);
        if (constructor.isPublic() || constructor.isProtected()) {
            return true;
        }

        return hasBuilderMethod(topLevelClass, potentialBuilder);
    }

    private boolean hasBuilderMethod(@NotNull ClassOrInterfaceDeclaration topLevelClass, @NotNull ClassOrInterfaceDeclaration builderClass) {
        List<MethodDeclaration> builderMethods = topLevelClass.getMethodsBySignature(BUILDER_FACTORY_METHOD_NAME);
        if (builderMethods.isEmpty()) {
            return false;
        }

        return builderMethods.stream().anyMatch(method -> method.isPublic() && method.isStatic()
                && returnsClass(method, builderClass));
    }

    private boolean checkBuildersMethods(@NotNull ClassOrInterfaceDeclaration potentialBuilder,
                                         @NotNull ClassOrInterfaceDeclaration topLevelClass) {
        List<MethodDeclaration> methods = potentialBuilder.getMethods();

        // Only one can match, because 0 parameters.
        Optional<MethodDeclaration> buildMethod = methods.stream().filter(method -> {
            if (!method.isPublic() && !method.isProtected()) {
                return false;
            }

            if (method.getParameters().isNonEmpty()) {
                return false;
            }

            return returnsClass(method, topLevelClass);
        }).findFirst();
        if (buildMethod.isEmpty()) {
            return false;
        }

        return methods.stream().filter(method -> !method.isStatic() && method.isPublic() && !method.equals(buildMethod.get()))
                .allMatch(method -> method.getType().isVoidType() || returnsClass(method, potentialBuilder));
    }

    private boolean returnsClass(@NotNull MethodDeclaration method,
                                 @NotNull ClassOrInterfaceDeclaration expectedReturnClass) {
        Type returnType = method.getType();
        if (!returnType.isClassOrInterfaceType()) {
            return false;
        }

        return returnType.asClassOrInterfaceType().getNameAsString().equals(expectedReturnClass.getNameAsString());
    }
}
